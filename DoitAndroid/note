
** 컴포넌트는 애플리케이션의 구성요소다

안드로이드 앱의 구조도 컴포넌트에 기반을 두므로 하나의 앱은 여러 컴포넌트로 구성된다.
*안드로이드에서는 클래스로 컴포넌트를 개발한다. 즉 하나의 클래스가 하나의 컴포넌트가 되는 것이다.
앱은 여러 클래스로 구분되는데 크게 컴포넌트 클래스와 일반 클래스로 구분한다.
앱이 실행될 때 클래스의 객체 생성부터 소멸까지 생명주기 관리를 개발자 코드에서 한다면 일반 클래스,
개발자가 만들기는 했지만 생명주기를 안드로이드 시스템에서 관리한다면 컴포넌트 클래스.

** 안드로이드 컴포넌트는 4종류다.

컴포넌트는 액티비티, 서비스, 콘텐츠 프로바이더, 브로드캐스트 리시버 4가지로 구분된다.
컴포넌트는 앱이 실행될 때 각각 다른 기능을 한다.

액티비티 : 화면을 구성하는 컴포넌트, 앱의 화면을 안드로이드폰에 출력하려면 액티비티를 만들어야 하며,
         앱이 실행되면 액티비티에서 출력한 내용이 안드로이드 폰에 나온다.

서비스 : 백그라운드 작업을 하는 컴포넌트, 화면 출력 기능이 없어서 실행되더라도 화면에는 출력되지 않는다.
        화면과 상관없이 백그라운드에서 장시간 실행해야 할 업무를 담당한다.
        (아마도, 데이터를 가져오는 작업 같은 것 이나 서버와 통신하는 부분들이 아닐까?)

콘텐츠 프로바이더 : 앱의 데이터를 공유하는 컴포넌트, 폰에는 많은 앱이 설치되어있고 액 간에 데이터를
                공유할 수도 있다. 하나의 앱이 자신의 데이터를 다른 앱에 공유하려면
                콘텐츠 프로바이더를 만들어야 하고, 다른 앱에서는 그 콘텐츠 프로바이더를 이용해
                데이터에 접근한다.
                ex) 카카오톡에서 프로필을 변경할 때 갤러리 앱의 사진을 이용할 수 있다.
                    이때 콘텐츠 프로바이더를 이용해 데이터를 주고 받는다.

브로드캐스트 리시버 : 시스템 이벤트가 발생할 때 실행되기 하는 컴포넌트.
                 여기서 이벤트란 화면에서 발생하는 사용자 이벤트가 아니라, 시스템에서 발생하는
                 특정 상황을 의미한다
                 예) 부팅완료, 배터리 방전 같은 상황을 말한다.

질문 : 안드로이드 시스템이 컴포넌트의 생명주기를 ㅗ간리하더라도 개발자가 만든 클래스인데 코드에서 직접
      생성해서 이용하면 안되나요?
답 : 안드로이드에서 컴포넌트는 각기 특정한 기능이 있다. 이것은 시스템에서 컴포넌트 클래스를 특별하게
     관리하기 때문이다. 컴포넌트 클래스를 개발자 코드로 직정 생성헤서 이용한다는 것은 컴포넌트 기능이
     없는 일반 클래스로 이용하겠다는 것과 같다. 따라서 개발자 코드로 컴포넌트 클래스의 생명주기를
     관리해서는 안된다.

4가지 컴포넌트를 구분하는 법

컴포넌트는 앱이 실행될 때 안드로이드 시스템에서 생명주기를 관리하는 클래스지만 개발자가 만들어야 한다.
개발자가 컴포넌트 클래스를 만들 때 지정된 클래스를 상속받아야 하는데 이 상위클래스를 보고 구분 할 수
있다. 액티비티 는 Activity 클래스를, 서비스는 Service, 콘텐츠 프로바이더는 ContentProvider,
브로드캐스트 리시버는 BroadcastReceiver 클래스를 상속받아서 만든다.

컴포넌트는 앱 안에서 독립된 실행 단위다.

컴포넌트는 애플리케이션 안에서 독립된 실행 단위라는 중요한 특징이 있다.
독립된 실행단위란 컴포넌트끼리 서로 종속되지 않아서 코드 결합이 발생ㅇ하지 않는다는 의미이다.

예) 카카오톡 채팅방 목록화면 = ListActivity, 채팅화면을 ChatActivity
   ListActivity 에서 ChatActivity 를 실행해 회면전환을 한다고 가정.

   ListActivity(이하 리스트) 에서 ChatActivity(이하 챗) 를 실행해야 하므로
   리스트에서 챗 객체를 생성해 실행하면 될 것 같다.
   두 클래스를 결합해서 실행하는 방법이다. 그런데 안드로이드에서는 이 방법은 불가능하다.
   컴포넌트의 생명주기를 시스템에서 관리하므로 코드에서 직접 객체를 실행할 수 없기 때문이다.

   그렇다면 어떻게 해야하나
   리스트에서 챗을 실행해야 한다면 안드로이드 시스템에 의뢰해서 시스템이 챗을 실행해야 한다.
   즉, 리스트와 책을 코드로 결합해서 직접 실행하는 것이 아니라 안드로이드 시스템에 의뢰함으로써
   두 클래스가 서로 종속되지 않고 독립해서 실행되게 해야 한다.

Any - 모든 타입 가능
Any 는 코틀린에서의 최상위 클래스. 모든 코틀린의 클래스는 Any 의 하위 클래스.
따라서 Any 타입으로 선언한 변수에는 모든 타입의 데이터를 할당할 수 있다.

Unit - 반환문이 없는 함수
Unit 은 다른 타입과 다르게 데이터의 형식이 아닌 특수한 상황을 표현하려는 목적으로 사용한다.
유닛 타입 사용 예
val data1 : Unit = Unit

Unit 타입으로 선언한 변수에는 Unit 객체만 대입할 수 있다. 따라서 Unit 타입으로 변수를 선언할 수는
있지만 의미가 없다. 이런 Unit 타입은 주로 함수의 반환 타입으로 사용한다.
함수에서 반환문이 없음을 명시적으로 나타낼 때 Unit 타입을 사용한다.
Unit 타입 사용 예 - 반환문이 없는 함수
fun some(): Unit {
    println(10 + 20)
}

함수를 선언할 때 반환 타입을 생략하면 자동으로 Unit 이 적용됌
위의 예와 같음
fun some(){
    println(10 + 20)
}


** View Class

뷰 클래스의 기본 구조
안드로이드에서 화면을 만들어 표시하는 컴포넌트는 액티비티이며 액티비티가 실행되면서 뷰 클래스를 이용해 화면을 구성한다.

뷰 객체의 계층 구조
액티비티 화면을 구성할 때 사용하는 클래스는 모두 View 의 하위 클래스이다.
그래서 화면구성과 관련한 클래스를 통칭하여 뷰 클래스라고 한다.

View : 모든 뷰 클래스의 최상위 클래스, 액티비티는 View 의 서브 클래스만 화면에 출력한다.
ViewGroup : View 의 하위 클래스지만 자체 UI 는 없어서 화면에 출력해도 아무것도 나오지 않는다.
            다른 뷰 여러개를 묶어서 제어할 목적으로 사용한다, ! 일종의 그릇 역할 !을 하는 클래스로, 일반적으로
            컨테이너 기능을 담당한다고 이야기 한다. 실제로는 ViewGroup 의 서브 클래스인
            레이아웃 클래스를 사용한다.
TextView : 특정 UI 를 출력할 목저으로 사용하는 클래스, 문자열을 출력하는 뷰이다.
